"""Migrate Hentai Data

Revision ID: 1636a3efb2ae
Revises: af01f97c978e
Create Date: 2018-02-21 20:58:39.688912

"""

# revision identifiers, used by Alembic.
revision = '1636a3efb2ae'
down_revision = 'af01f97c978e'
branch_labels = None
depends_on = None



import datetime
import tqdm
import json
import hashlib
import os.path

from alembic import op
import sqlalchemy as sa
import sqlalchemy_utils

# Patch in knowledge of the citext type, so it reflects properly.
from sqlalchemy.orm.session import Session
from sqlalchemy.dialects.postgresql.base import ischema_names
import citext
from sqlalchemy.dialects.postgresql import ENUM
from sqlalchemy.dialects.postgresql import JSON
from sqlalchemy.dialects.postgresql import TSVECTOR
ischema_names['citext'] = citext.CIText


import MangaCMSOld.lib.dbPool
import MangaCMS.db as db

def get_add_file(sess, fname, fpath):
	if fpath is None or fname is None:
		return None
	fqname = os.path.join(fpath, fname)
	if not os.path.exists(fqname):
		return None

	have = sess.query(db.ReleaseFile)             \
		.filter(db.ReleaseFile.dirpath == fpath)  \
		.filter(db.ReleaseFile.filename == fname) \
		.scalar()

	if have:
		return have


	# print("Hashing file...", end="", flush=True)
	hash_md5 = hashlib.md5()
	with open(fqname, "rb") as f:
		for chunk in iter(lambda: f.read(4096*16), b""):
			hash_md5.update(chunk)
	fhash = hash_md5.hexdigest()
	# print("done.")


	have = sess.query(db.ReleaseFile)          \
		.filter(db.ReleaseFile.fhash == fhash) \
		.scalar()

	if have:
		# print("Have by fhash")
		return have

	new = db.ReleaseFile(
		dirpath  = fpath,
		filename = fname,
		fhash    = fhash
		)
	sess.add(new)
	return new

def migrate_tags(row, flags, tags):
	# print("Tags:", tags)
	tags = tags.split(" ")
	tags = [tmp for tmp in tags if not tmp.startswith("crosslink-")]

	tags = [tmp.replace("-(female)", "-female").replace("-(male)", "-male") for tmp in tags]

	tags = set(tags)
	tags = tags - set(["phash-duplicate", "was-duplicate", "uploaded", 'dup-checked', 'deleted'])

	if not tags:
		return

	# print("Tags:", tags)
	# print("Flags:", flags)
	if row.file:
		# for tag in tags:
		print("Adding tag:", tags)
		row.file.hentai_tags = tags
	else:
		row.additional_metadata['tags'] = list(tags)

def dlstate_decode(state_int):

	state_val = "new"
	if state_int == 1:
		state_val = 'fetching'
	elif state_int == 2:
		state_val = 'complete'
	elif state_int == 3:
		state_val = 'upload'
	elif state_int > 3:
		state_val = 'disabled'
	elif state_int < 0:
		state_val = 'error'
	return state_val

def dirstate_decode(flags):

	dirstate_val = "unknown"
	if "haddir" in flags:
		dirstate_val = "had_dir"
	elif "new_dir" in flags:
		dirstate_val = "new_dir"
	return dirstate_val


def upgrade():
	# ### commands auto generated by Alembic - please adjust! ###

	old_con = MangaCMSOld.lib.dbPool.pool.getconn()
	old_cur = old_con.cursor()
	bind = op.get_bind()
	sess = Session(bind=bind)
	print("DB Module:", db)
	print("Connection:", old_con)
	print("Cursor:", old_cur)
	print("Session:", sess)
	old_cur.execute("SELECT sourcesite, dlstate, sourceurl, retreivaltime, lastupdate, sourceid, seriesname, filename, originname, downloadpath, flags, tags, note FROM hentaiitems ORDER BY dbid ASC")

	fetchchunk = 1000
	items = []

	print("Loading rows from DB")
	prog = tqdm.tqdm()
	chunk = old_cur.fetchmany(size=fetchchunk)
	while chunk:
		items.extend(chunk)
		prog.update(len(chunk))
		chunk = old_cur.fetchmany(size=fetchchunk)

	print("Loading rows from DB")

	new = 0
	for item in tqdm.tqdm(items):
		sourcesite, dlstate, sourceurl, retreivaltime, lastupdate, sourceid, seriesname, filename, originname, downloadpath, flags, tags, note = item

		have = sess.query(db.HentaiReleases)             \
			.filter(db.HentaiReleases.source_id == sourceurl) \
			.scalar()

		if have:
			migrate_tags(have, flags, tags)
			print("Skipping!")
			continue

		file = get_add_file(sess, filename, downloadpath)
		sess.flush()

		# print("'{}', '{}'".format(flags, tags))
		tags = tags if tags else ""
		flags = flags if flags else ""

		state_val = dlstate_decode(dlstate)
		dirstate_val = dirstate_decode(flags)


		additional_metadata = {}
		if file is None:
			state_val = 'missing'
			additional_metadata = {
				'filename'     : filename,
				'downloadpath' : downloadpath,
			}



		if sourceid:
			loaded_meta = json.loads(sourceid)

			additional_metadata['sourceid'] = loaded_meta
		if note:
			additional_metadata['note'] = note
			# print("Note:", note)


		row = db.HentaiReleases(
				state               = state_val,
				err_str             = None,
				source_site         = sourcesite,
				series_name         = seriesname,
				source_id           = sourceurl,
				posted_at           = datetime.datetime.utcfromtimestamp(lastupdate),
				downloaded_at       = datetime.datetime.utcfromtimestamp(retreivaltime),
				phash_duplicate     = "phash-duplicate" in tags,
				was_duplicate       = "was-duplicate" in tags,
				uploaded            = "uploaded" in tags,
				deleted             = "deleted" in tags,
				dirstate            = dirstate_val,
				origin_name         = originname,
				additional_metadata = additional_metadata,
				fileid              = file.id if file else None,
			)
		sess.add(row)
		migrate_tags(row, flags, tags)

		new += 1
		if new > 1000:
			new = 0
			print("\nCommitting!\n")

			sess.flush()
			sess.commit()
			bind.execute("""COMMIT""")

	raise RuntimeError("Wat?")
	pass
	# ### end Alembic commands ###


def downgrade():
	# ### commands auto generated by Alembic - please adjust! ###
	pass
	# ### end Alembic commands ###
